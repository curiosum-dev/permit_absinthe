defmodule Permit.Absinthe.Middleware.DataloaderSetup do
  @moduledoc """
  Middleware for dynamically setting up authorization-aware dataloaders in Absinthe GraphQL resolution.

  This middleware automatically configures `Permit.Absinthe.Dataloader` sources during field resolution,
  taking into account the current authorization context including the current user, authorization module,
  and action being performed. This allows for authorization-aware data loading that respects permissions
  at the database query level.

  ## Problem Solved

  Traditional Absinthe dataloader setup happens in the schema's `context/1` callback, which occurs
  before field-specific authorization metadata is available. This middleware solves the problem by:

  1. Extracting authorization metadata from the current field resolution
  2. Creating dataloaders that are aware of the specific authorization context
  3. Dynamically adding authorization-aware sources to the dataloader
  4. Ensuring each authorization context gets its own isolated dataloader source

  ## Usage

  ### 1. Middleware Injection (Top-level fields)

  Add this middleware to top-level query/mutation fields to set up the dataloader sources:

  ```elixir
  field :me, :user do
    middleware Permit.Absinthe.Middleware.DataloaderSetup
    resolve &UserResolver.me/3
  end
  ```

  ### 2. Resolver Usage (Nested object fields)

  Use the configured dataloader sources in nested object field resolvers:

  ```elixir
  object :user do
    field :articles, list_of(:article) do
      resolve &authorized_dataloader/3
    end
  end
  ```

  The `authorized_dataloader/3` resolver function would use the dataloader source key
  generated by this middleware to load data with proper authorization.
  repository to use for database queries (required)

  ## Behavior

  The middleware:

  1. Extracts permit metadata from the current field and type
  2. Determines the authorization module and action from field metadata
  3. Gets the current user from the resolution context
  4. Creates a `Permit.Absinthe.Dataloader` source with the authorization context
  5. Adds the source to the dataloader with a unique key based on authorization parameters
  6. Updates the resolution context with the configured dataloader

  ## Source Key Generation

  Each dataloader source is assigned a unique key in the format:
  `"<authorization_module>:<field_name>:<action>"`

  This ensures that different authorization contexts don't interfere with each other,
  allowing multiple fields with different permissions to coexist in the same query.

  ## Dependencies

  This middleware requires:
  - `Permit.Absinthe.Schema.Meta` for extracting field metadata
  - `Permit.Absinthe.Dataloader` for creating authorization-aware sources
  - Field metadata configured with permit authorization information
  """

  @behaviour Absinthe.Middleware
  alias Permit.Absinthe.Schema.{Helpers, Meta}

  @impl true
  def call(resolution, _opts) do
    # Extract authorization info from resolution
    field_meta = Meta.get_field_meta_from_resolution(resolution, :permit)

    authorization_module = Meta.get_field_meta_from_resolution(resolution, :authorization_module)
    repo = authorization_module.repo()
    action = field_meta[:action] || Helpers.default_action(resolution)
    current_user = resolution.context[:current_user]

    # Create context-specific dataloader source
    source = Permit.Absinthe.Dataloader.new(repo, authorization_module, current_user, action)

    # Create or update dataloader in context
    dataloader =
      case resolution.context[:dataloader] do
        nil -> Dataloader.new(timeout: Dataloader.default_timeout())
        existing -> existing
      end

    # Add source with a unique key based on authorization params
    field_name = resolution.definition.schema_node.identifier
    source_key = "#{inspect(authorization_module)}:#{field_name}:#{action}"
    dataloader = Dataloader.add_source(dataloader, source_key, source)

    # Update context
    new_context = Map.put(resolution.context, :loader, dataloader)
    %{resolution | context: new_context}
  end
end
